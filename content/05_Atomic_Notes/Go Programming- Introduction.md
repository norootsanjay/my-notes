# Hello World

```go
package main

import "fmt"

func main(){
	fmt.Println("Hello World");
}
```

```bash
go run hello.go
```

The command `go run` is used to compile and execute a program at the same time without explicitly creating a binary file.


- [f] ==go run== -> ==compiles into a temporary executable file in memory== -> ==runs==
---

# Go Compiler

- **Compiler**: Translator of Go
- **Runtime**: Manages the execution of the program, memory allocation, garbage collection, etc...
The workflow of going from Go source code to execution on the processor involves the following major stages: the Go compiler, the Go runtime, and the processor itself. Here's a summarized step-by-step workflow:

1. **Go Compiler Workflow:**
    - **Lexical Analysis (Scanning):** The compiler breaks down raw Go source code into tokens (smallest units like keywords, identifiers, operators).
    - **Parsing:** The tokens are arranged into an Abstract Syntax Tree (AST) which represents the program's syntax structure.
    - **Type Checking:** Verify that operations in the code are type-safe and consistent with Go's type system.
    - **Intermediate Representation (IR) Construction:** The AST is converted into an intermediate representation that the compiler can optimize.
    - **Optimization Passes:** Various optimizations occur here such as dead code elimination, function inlining, escape analysis.
    - **Machine Code Generation:** The optimized IR is translated into machine-specific assembly code.
    - **Assembly and Linking:** The assembly code is converted to machine code instructions and linked into a single executable binary that can run on the target platform.
        
2. **Go Runtime Role:**
    - When the compiled Go executable runs, the runtime is part of the binary and manages important tasks like:
        - **Goroutine Scheduling:** Manages lightweight concurrent threads (goroutines) by multiplexing them onto OS threads.
        - **Memory Management:** Includes garbage collection and stack/heap allocation.
        - **System Calls:** Interfaces with the OS for I/O and threading.
        - **Startup Initialization:** Prepares the environment before the main Go program starts.
            
3. **Processor Execution:**
    - The executable binary runs directly on the processor.
    - Machine instructions generated by the Go compiler are executed on the CPU cores.
    - The OS runs threads that the Go runtime schedules goroutines on.
    - Processor handles arithmetic, logic, memory access, and concurrency operations as instructed by the compiled Go program and runtime.

In essence, the Go compiler converts your source code into a machine-executable file, the Go runtime provides necessary system-level and concurrency support at program execution, and the processor performs the actual execution of machine instructions on hardware. This workflow enables Go to combine compiled performance with powerful concurrency features efficiently.

---

# Data Types

1. Integer
2. Floating Point Number
3. Complex Number
4. Booleans
5. Strings
6. Constants
7. Arrays
8. Structs
9. Pointers
10. Maps
11. Slices
12. Functions
13. Channels
14. JSON
15. Text and HTML Templates

### Signed Integers

- `int8`: -128 to 127 (1 byte)
- `int16`: -32,768 to 32,767 (2 bytes)
- `int32`: -2,147,483,648 to 2,147,483,647 (4 bytes)
- `int64`: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (8 bytes)
- `int`: Platform-dependent (32 or 64 bits)

### Unsigned Integers

- `uint8` (alias `byte`): 0 to 255
- `uint16`: 0 to 65,535
- `uint32`: 0 to 4,294,967,295
- `uint64`: 0 to 18,446,744,073,709,551,615
- `uint`: Platform-dependent
- `uintptr`: Holds pointer addresses

### Key Insights

```go
// Always prefer sized types for structs and APIs
type Config struct {
    Port     uint16 // Clear intent: valid port range
    MaxConns int32  // Explicit 32-bit limit
}

// Use int for counters and indices (idiomatic Go)
for i := 0; i < len(slice); i++ {
    // int is the natural choice here
}
```

**Pro Tip**: Integer overflow is silent in Go. Use explicit checks for critical calculations.

---

## 2. Floating Point Numbers

Go follows IEEE 754 standard with two types:

- `float32`: 32-bit floating point (~6 decimal precision)
- `float64`: 64-bit floating point (~15 decimal precision, default)

### Best Practices

go

```go
// Always use float64 unless memory is critical
var price float64 = 19.99

// Be aware of precision limits
var f1 float32 = 16777216.0
var f2 float32 = 16777217.0
fmt.Println(f1 == f2) // true! Precision lost

// For financial calculations, use integers or decimal libraries
// cents := int64(price * 100) // Store as cents
```

**Warning**: Never use floating point for money calculations due to precision issues.

---

## 3. Complex Numbers

Go has built-in support for complex numbers:

- `complex64`: Real and imaginary parts are float32
- `complex128`: Real and imaginary parts are float64 (default)

go

```go
// Creating complex numbers
c1 := 3 + 4i
c2 := complex(3.0, 4.0)

// Built-in functions
real(c1)    // 3.0
imag(c1)    // 4.0
abs := cmplx.Abs(c1) // Magnitude: 5.0

// Use case: Signal processing, scientific computing
func fft(input []complex128) []complex128 {
    // Fast Fourier Transform implementation
}
```

---

# Go Naming Conventions

- **PascalCase**: Structs, interface, enums.
- **snake_case**: variables, constants, filenames
- **UPPERCASE**: Constants
- **mixedCase**: variables
## Core Principles

Go's naming conventions are not just stylistic choices—they're deeply integrated into the language's tooling, documentation generation, and visibility rules. After decades of Go development, these patterns have proven essential for maintainable codebases.

### Fundamental Rules

1. **Case determines visibility**: Exported (public) vs unexported (private)
2. **Shorter names for shorter scopes**: `i` in loops, `ctx` for context
3. **Descriptive names for longer scopes**: Package-level variables and functions
4. **No underscores**: Use camelCase, not snake_case
5. **Acronyms stay uppercase**: `HTTP`, `JSON`, `ID`, `URL`

---

## Package Naming

Packages are the foundation of Go's module system and should be named with extreme care.

### Package Name Rules

```go
// ✅ Good: Short, clear, lowercase
package http
package json
package strings
package bufio  // buffered I/O

// ❌ Avoid: Uppercase, underscores, generic names
package HTTP
package string_utils
package utils
package common
package helpers
```

### Package Naming Best Practices

```go
// ✅ Use singular nouns
package user      // not users
package config    // not configuration
package auth      // not authentication

// ✅ Avoid stuttering (package.Type repetition)
package user
type User struct{} // user.User (acceptable)
type Manager struct{} // user.Manager (better)

// ✅ Context-specific names
package httputil  // HTTP utilities
package sqldb     // SQL database operations
package grpcauth  // gRPC authentication

// ✅ Domain-specific abbreviations
package k8s       // Kubernetes (widely understood)
package oauth     // OAuth (industry standard)
package jwt       // JSON Web Tokens
```

### Package Import Practices

```go
// ✅ Good: Clear, no conflicts
import (
    "context"
    "database/sql"
    "net/http"
    
    "github.com/company/project/internal/user"
    "github.com/company/project/internal/auth"
)

// ✅ Use aliases for conflicts or clarity
import (
    "database/sql"
    sqldriver "database/sql/driver"
    
    userv1 "github.com/company/project/api/user/v1"
    userv2 "github.com/company/project/api/user/v2"
)

// ✅ Group imports properly
import (
    // Standard library first
    "fmt"
    "log"
    "net/http"
    
    // External dependencies
    "github.com/gorilla/mux"
    "go.uber.org/zap"
    
    // Internal packages last
    "github.com/company/project/internal/config"
    "github.com/company/project/internal/database"
)
```

---

## Variables

Variable naming should reflect scope, purpose, and lifetime.

### Local Variables

```go
// ✅ Short names for short scopes
func processUsers() {
    for i, u := range users {          // i = index, u = user
        if u.Active {
            fmt.Printf("User %d: %s\n", i, u.Name)
        }
    }
}

// ✅ Single letter for very short scopes
func quickSort(arr []int, low, high int) {
    if low < high {
        p := partition(arr, low, high)  // p = pivot
        quickSort(arr, low, p-1)
        quickSort(arr, p+1, high)
    }
}

// ✅ Descriptive names for longer scopes
func processOrder(orderID string) error {
    var (
        customer        *Customer
        paymentMethod   *PaymentMethod
        shippingAddress *Address
        orderTotal      decimal.Decimal
        taxAmount       decimal.Decimal
    )
    
    // Function body with meaningful variable names
    customer, err := customerService.GetByOrderID(orderID)
    if err != nil {
        return fmt.Errorf("failed to get customer: %w", err)
    }
    // ... rest of function
}
```

### Package-Level Variables

```go
// ✅ Exported variables: Start with uppercase
var (
    DefaultTimeout = 30 * time.Second
    MaxRetries     = 3
    APIVersion     = "v1"
)

// ✅ Unexported variables: Start with lowercase
var (
    httpClient    = &http.Client{Timeout: DefaultTimeout}
    logger        = log.New(os.Stdout, "", log.LstdFlags)
    configPath    = "/etc/myapp/config.yaml"
)

// ✅ Use var blocks for related variables
var (
    // Database configuration
    dbHost     = os.Getenv("DB_HOST")
    dbPort     = os.Getenv("DB_PORT")
    dbName     = os.Getenv("DB_NAME")
    dbUser     = os.Getenv("DB_USER")
    dbPassword = os.Getenv("DB_PASSWORD")
)

// ✅ Constants for immutable values
const (
    DefaultPort     = 8080
    MaxFileSize     = 10 << 20 // 10 MB
    ConfigFileName  = "config.yaml"
    APIKeyHeader    = "X-API-Key"
)
```

### Common Variable Naming Patterns

```go
// ✅ Standard abbreviations (widely accepted)
var (
    ctx    context.Context    // context
    cfg    *Config           // config
    db     *sql.DB           // database
    req    *http.Request     // request
    resp   *http.Response    // response
    err    error             // error
    buf    []byte            // buffer
    mu     sync.Mutex        // mutex
    wg     sync.WaitGroup    // wait group
    ch     chan Message      // channel
)

// ✅ Loop variables
for i, v := range slice { ... }      // index, value
for k, v := range map { ... }        // key, value
for i := 0; i < n; i++ { ... }       // index

// ✅ Receiver names (see Methods section)
func (u *User) GetName() string { ... }      // u for User
func (c *Client) Connect() error { ... }     // c for Client
func (s *Server) Start() error { ... }       // s for Server
```

---

## Functions

Function names should clearly describe what they do, starting with a verb when possible.

### Function Naming Patterns

```go
// ✅ Exported functions: Start with uppercase, use verbs
func GetUser(id string) (*User, error) { ... }
func CreateOrder(req CreateOrderRequest) (*Order, error) { ... }
func ValidateEmail(email string) bool { ... }
func ParseConfig(filename string) (*Config, error) { ... }

// ✅ Unexported functions: Start with lowercase
func validateInput(input string) error { ... }
func connectToDatabase() (*sql.DB, error) { ... }
func formatResponse(data interface{}) []byte { ... }

// ✅ Boolean functions: Use "Is", "Has", "Can", "Should"
func IsValid(user *User) bool { ... }
func HasPermission(user *User, resource string) bool { ... }
func CanAccess(user *User, resource *Resource) bool { ... }
func ShouldRetry(err error) bool { ... }

// ✅ Constructor functions
func NewUser(name, email string) *User { ... }
func NewHTTPClient(timeout time.Duration) *http.Client { ... }
func NewConfig() *Config { ... }

// ✅ Factory functions
func CreateUserFromJSON(data []byte) (*User, error) { ... }
func BuildQuery(params QueryParams) string { ... }
func MakeHandler(service UserService) http.HandlerFunc { ... }
```

### Function Parameter Naming

```go
// ✅ Clear, concise parameter names
func ProcessPayment(amount decimal.Decimal, cardNumber, cvv string) error { ... }
func SendEmail(to, from, subject, body string) error { ... }
func CreateUser(name, email string, age int) (*User, error) { ... }

// ✅ Use context.Context as first parameter
func GetUser(ctx context.Context, userID string) (*User, error) { ... }
func ProcessOrder(ctx context.Context, orderID string) error { ... }

// ✅ Group related parameters
func ConnectDB(host, port, database, username, password string) (*sql.DB, error) { ... }

// ✅ Better: Use struct for many parameters
type DBConfig struct {
    Host     string
    Port     string
    Database string
    Username string
    Password string
}

func ConnectDB(config DBConfig) (*sql.DB, error) { ... }
```

---

## Types (Structs, Interfaces, etc.)

Type names should be nouns and clearly indicate what they represent.

### Struct Naming

```go
// ✅ Exported structs: Uppercase, descriptive nouns
type User struct {
    ID        string    `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

type HTTPServer struct {
    Port    int
    Handler http.Handler
    Logger  *log.Logger
}

type DatabaseConfig struct {
    Host            string        `yaml:"host"`
    Port            int           `yaml:"port"`
    MaxConnections  int           `yaml:"max_connections"`
    ConnectTimeout  time.Duration `yaml:"connect_timeout"`
}

// ✅ Unexported structs: Lowercase
type userRepository struct {
    db *sql.DB
}

type httpClient struct {
    baseURL string
    client  *http.Client
}
```

### Interface Naming

```go
// ✅ Single-method interfaces: Use -er suffix
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

type Stringer interface {
    String() string
}

// ✅ Multi-method interfaces: Descriptive names
type UserService interface {
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, id string, req UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id string) error
}

type PaymentProcessor interface {
    ProcessPayment(ctx context.Context, payment *Payment) (*Receipt, error)
    RefundPayment(ctx context.Context, paymentID string) error
    GetPaymentStatus(ctx context.Context, paymentID string) (PaymentStatus, error)
}

// ✅ Composition interfaces
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

### Custom Types and Aliases

```go
// ✅ Custom types for domain concepts
type UserID string
type OrderStatus int
type EmailAddress string
type PhoneNumber string

// ✅ Constants for custom types
const (
    OrderStatusPending OrderStatus = iota
    OrderStatusConfirmed
    OrderStatusShipped
    OrderStatusDelivered
    OrderStatusCancelled
)

// ✅ Type aliases for external types
type Duration = time.Duration
type Context = context.Context

// ✅ Function types
type HandlerFunc func(http.ResponseWriter, *http.Request)
type ValidatorFunc func(interface{}) error
type ProcessorFunc func(context.Context, *Message) error
```

---

## Methods

Method names follow the same rules as functions but with specific receiver naming conventions.

### Method Receiver Naming

```go
// ✅ Use first letter(s) of type name, lowercase
type User struct {
    Name  string
    Email string
}

func (u *User) GetName() string { return u.Name }
func (u *User) SetEmail(email string) { u.Email = email }

type HTTPClient struct {
    baseURL string
    client  *http.Client
}

func (c *HTTPClient) Get(url string) (*http.Response, error) { ... }
func (c *HTTPClient) Post(url string, body io.Reader) (*http.Response, error) { ... }

// ✅ For longer type names, use more letters
type DatabaseConnection struct { ... }
func (db *DatabaseConnection) Query(sql string) (*Rows, error) { ... }

type UserRepository struct { ... }
func (ur *UserRepository) FindByID(id string) (*User, error) { ... }

// ✅ Avoid generic names like "self", "this", "me"
// ❌ Bad
func (self *User) GetName() string { ... }
func (this *HTTPClient) Get(url string) (*http.Response, error) { ... }
```

### Method Naming Patterns

```go
type User struct {
    name   string
    email  string
    active bool
}

// ✅ Getters: Just the field name (no "Get" prefix)
func (u *User) Name() string { return u.name }
func (u *User) Email() string { return u.email }
func (u *User) IsActive() bool { return u.active } // Boolean: "Is" prefix

// ✅ Setters: "Set" prefix
func (u *User) SetName(name string) { u.name = name }
func (u *User) SetEmail(email string) { u.email = email }
func (u *User) SetActive(active bool) { u.active = active }

// ✅ Action methods: Use verbs
func (u *User) Activate() { u.active = true }
func (u *User) Deactivate() { u.active = false }
func (u *User) Validate() error { ... }
func (u *User) Save(db *sql.DB) error { ... }

// ✅ Query methods
func (u *User) HasPermission(permission string) bool { ... }
func (u *User) CanAccess(resource string) bool { ... }
func (u *User) String() string { ... } // Implement fmt.Stringer
```

---

## Constants and Enums

Constants should clearly indicate their immutable nature and purpose.

### Constant Naming

```go
// ✅ Exported constants: Uppercase
const (
    MaxRetries      = 3
    DefaultTimeout  = 30 * time.Second
    APIVersion      = "v1"
    ConfigFileName  = "config.yaml"
)

// ✅ Unexported constants: Lowercase
const (
    bufferSize     = 4096
    maxConnections = 100
    retryInterval  = time.Second
)

// ✅ Group related constants
const (
    // HTTP status codes (if not using http package constants)
    StatusOK                  = 200
    StatusBadRequest         = 400
    StatusUnauthorized       = 401
    StatusInternalServerError = 500
)

// ✅ Use iota for enumerations
type LogLevel int

const (
    LogLevelDebug LogLevel = iota
    LogLevelInfo
    LogLevelWarn
    LogLevelError
    LogLevelFatal
)

// ✅ String representation for enums
func (l LogLevel) String() string {
    switch l {
    case LogLevelDebug:
        return "DEBUG"
    case LogLevelInfo:
        return "INFO"
    case LogLevelWarn:
        return "WARN"
    case LogLevelError:
        return "ERROR"
    case LogLevelFatal:
        return "FATAL"
    default:
        return "UNKNOWN"
    }
}
```

### Advanced Constant Patterns

```go
// ✅ Bit flags with iota
type Permission int

const (
    PermissionRead Permission = 1 << iota
    PermissionWrite
    PermissionExecute
    PermissionDelete
)

// ✅ Size constants
const (
    _          = iota // Skip first value
    KB float64 = 1 << (10 * iota)
    MB
    GB
    TB
)

// ✅ Configuration keys
const (
    EnvDatabaseURL    = "DATABASE_URL"
    EnvServerPort     = "SERVER_PORT"
    EnvLogLevel       = "LOG_LEVEL"
    EnvDebugMode      = "DEBUG_MODE"
)
```

---

## Files and Directories

File and directory naming affects project organization and Go tool behavior.

### File Naming

```go
// ✅ Main package files
main.go              // Entry point
cmd/myapp/main.go    // CLI application

// ✅ Package files: lowercase, descriptive
user.go              // User struct and methods
user_service.go      // UserService interface and implementation
user_repository.go   // UserRepository implementation
user_handler.go      // HTTP handlers for user operations

// ✅ Test files: _test.go suffix
user_test.go
user_service_test.go
user_integration_test.go

// ✅ Build constraint files
user_linux.go        // Linux-specific implementation
user_windows.go      // Windows-specific implementation
user_mock.go         // Mock implementations
```

### Directory Structure

```
project/
├── cmd/                    # Application entry points
│   ├── server/
│   │   └── main.go
│   └── cli/
│       └── main.go
├── internal/               # Private application code
│   ├── user/
│   │   ├── user.go
│   │   ├── service.go
│   │   └── repository.go
│   ├── auth/
│   └── config/
├── pkg/                    # Public library code
│   ├── httputil/
│   └── validation/
├── api/                    # API definitions
│   └── v1/
├── web/                    # Web assets
├── scripts/               # Build and deploy scripts
├── docs/                  # Documentation
├── go.mod
└── go.sum
```

---

## Advanced Naming Conventions

### Error Naming

```go
// ✅ Error variables: Err prefix
var (
    ErrUserNotFound     = errors.New("user not found")
    ErrInvalidEmail     = errors.New("invalid email address")
    ErrDatabaseTimeout  = errors.New("database operation timed out")
    ErrUnauthorized     = errors.New("unauthorized access")
)

// ✅ Custom error types
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s: %s", e.Field, e.Message)
}

// ✅ Error handling functions
func IsNotFound(err error) bool { ... }
func IsTimeout(err error) bool { ... }
func IsValidation(err error) bool { ... }
```

### Test Naming

```go
// ✅ Test function naming: TestFunctionName_Scenario
func TestCreateUser_ValidInput_Success(t *testing.T) { ... }
func TestCreateUser_InvalidEmail_ReturnsError(t *testing.T) { ... }
func TestCreateUser_DuplicateEmail_ReturnsError(t *testing.T) { ... }

// ✅ Benchmark functions: BenchmarkFunctionName
func BenchmarkCreateUser(b *testing.B) { ... }
func BenchmarkHashPassword(b *testing.B) { ... }

// ✅ Example functions: ExampleFunctionName
func ExampleCreateUser() {
    user, err := CreateUser("John Doe", "john@example.com")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(user.Name)
    // Output: John Doe
}
```

### Context and Cancellation

```go
// ✅ Context parameter naming
func ProcessOrder(ctx context.Context, orderID string) error { ... }
func GetUser(ctx context.Context, userID string) (*User, error) { ... }

// ✅ Context values keys (use custom types)
type contextKey string

const (
    userContextKey    contextKey = "user"
    requestIDKey      contextKey = "request_id"
    traceIDKey        contextKey = "trace_id"
)

// ✅ Context helper functions
func UserFromContext(ctx context.Context) (*User, bool) {
    user, ok := ctx.Value(userContextKey).(*User)
    return user, ok
}

func WithUser(ctx context.Context, user *User) context.Context {
    return context.WithValue(ctx, userContextKey, user)
}
```

---

## Common Anti-Patterns to Avoid

### What NOT to Do

```go
// ❌ Hungarian notation
var strName string
var intAge int
var boolActive bool

// ❌ Underscores in names
func get_user_by_id(id string) *User { ... }
var user_name string
const MAX_RETRY_COUNT = 3

// ❌ Generic/meaningless names
func DoStuff(thing interface{}) interface{} { ... }
var data interface{}
var result []interface{}
func Handle(ctx context.Context) error { ... }

// ❌ Stuttering (except when unavoidable)
package user
type UserUser struct { ... }        // user.UserUser
func UserCreateUser() *User { ... } // user.UserCreateUser

// ❌ Overly long names
func CreateUserAccountWithEmailVerificationAndPasswordHashing() { ... }
var databaseConnectionConfigurationSettings *DatabaseSettings

// ❌ Inconsistent naming
func GetUser(id string) *User { ... }
func FetchOrder(id string) *Order { ... }  // Should be GetOrder
func DeleteProduct(id string) { ... }
func RemoveCategory(id string) { ... }     // Should be DeleteCategory

// ❌ Mixing naming conventions
type UserService interface {
    getUser(id string) *User      // Should be GetUser (exported)
    Create_User(user *User) error // Should be CreateUser
}
```

---

## Tools and Validation

### Go Tools for Naming

```bash
# Format code (fixes basic naming issues)
go fmt ./...

# Vet code (catches some naming problems)
go vet ./...

# Lint with golint (checks naming conventions)
golint ./...

# Use golangci-lint for comprehensive checking
golangci-lint run
```

### IDE Integration

Most Go IDEs and editors provide:

- Real-time naming convention validation
- Automatic formatting with gofmt
- Refactoring tools for renaming
- Auto-completion based on naming patterns

---

## Summary: The Go Way

Go's naming conventions are designed to:

1. **Enhance readability** - Clear, consistent names reduce cognitive load
2. **Enable tooling** - gofmt, godoc, and other tools rely on naming conventions
3. **Indicate visibility** - Case determines public/private access
4. **Reduce ceremony** - Simple, direct names over verbose ones
5. **Support maintenance** - Consistent patterns help teams collaborate

### Quick Reference Checklist

- [ ] Package names: short, lowercase, no underscores
- [ ] Exported identifiers: start with uppercase
- [ ] Unexported identifiers: start with lowercase
- [ ] Variables: short names for short scopes, descriptive for long scopes
- [ ] Functions: start with verbs, clear action indication
- [ ] Interfaces: -er suffix for single methods
- [ ] Constants: grouped logically, use iota for enums
- [ ] Receivers: 1-2 letter abbreviation of type name
- [ ] Avoid stuttering, underscores, and generic names
- [ ] Use standard abbreviations: ctx, cfg, db, err, etc.

Remember: Good naming is one of the most important aspects of writing maintainable Go code. When in doubt, favor clarity over brevity, but keep Go's preference for conciseness in mind.

---
# Struct Embedding

```go
package main

import "fmt"

type Person struct {
	name string
	age  int
}

type Employee struct {
	empId int
	Person // composition 
}

func main() {
	e1 := Employee{
		empId:  3,
		Person: Person{name: "sanjay", age: 21},
	}

	fmt.Println(e1.name) // because of struct embedding, we can directly access name through e1 instance.
	fmt.Println(e1.age)
	fmt.Println(e1.empId)

}

```

```go
package main

import "fmt"

type Person struct {
	name string
	age  int
}

type Employee struct {
	empId int
	employeePerson Person // struct field
}

func main() {
	e1 := Employee{
		empId:  3,
		Person: Person{name: "sanjay", age: 21},
	}

	fmt.Println(e1.employeePerson.name)
	fmt.Println(e1.employeePerson.age)
	fmt.Println(e1.empId)

}
```
## Best Practice
- Use composition over inheritance
- Avoid the diamond problem
- Clarity and readability
- Initialization

